比较全面且系统地讲解分析原型继承的例子

## 首先创建对象的几种方法
### 字面量
```js
var obj1 = {name: "obj1"};
var obj2 = new Object({name: "obj2"});
```
### 构造函数
```js
var M = function(name) {
  this.name = name;
}
var obj3 = new M("obj3");
```
### Object.create
```js
var p = {name: "p"};
var obj4 = Object.create(p)
```
##### 三种方式分析：
###### 字面量方式两个创建的是同一种类型的对象
###### 构造函数方式是通过实例化方式创建（new）出来的一个实例对象
###### 最后Object.create实际上是构造出来一个空构造函数，这个空构造函数的原型对象指向传入对象，返回这个空构造函数的实例对象
```js
Object.create = function(o) {
  var f = function() {};
  f.prototype = o;
  return new f();
}
```

## 下面主要讲继承的几种实现方式及优缺点
+ ### 借助构造函数实现继承
```js
function Parent1() {
  this.name = "parent1";
}
function Child1() {
  Parent1.call(this);
  this.type = "child1";
}
```
##### 缺点：
###### 原型对象无法继承

+ ### 原型链实现继承
```js
function Parent2() {
  this.name = "parent2";
}
function Child2() {
  this.type = "child2";
}
Child2.prototype = new Parent2();
```
##### 缺点
###### Child2实例化的两个（对象）实例，改一个对象的属性，另一个对象的属性也变化了
###### 原因：两个对象，原型链的原型对象是共用的
```js
var s1 = new Child2();
var s2 = new Child2();
s1.__proto__ === s2.__proto__;
```

+ ### 组合方式实现继承
```js
function Parent3() {
  this.name = "parent3";
}
function Child3() {
  Parent3.call(this);
  this.type = "child3";
}
Child3.prototype = new Parent3();
```
##### 缺点
###### Child3实例化的时候，Parent3执行两次
